# 자동매매 프로그램 안정성 향상을 위한 코드 개선 방안

## 1. 도입

본 문서는 현재 개발된 자동매매 프로그램의 코드 품질을 향상시키고, 특히 **안정적인 운영**을 최우선 목표로 하는 구체적인 개선 방안을 제안합니다. 자동매매 시스템에서 안정성은 예측 불가능한 시장 상황에서도 오류 없이 일관된 성능을 유지하고, 자산을 보호하며, 신뢰할 수 있는 거래를 수행하기 위한 핵심 요소입니다.

제안된 개선 사항들은 코드의 복잡도를 낮추고, 잠재적인 버그 발생 가능성을 줄이며, 유지보수와 디버깅을 용이하게 만들어 시스템 전반의 안정성을 높이는 데 중점을 둡니다.

## 2. 주요 개선 영역 및 방안 (안정성 기여도 순)

### 2.1. 긴 함수/메서드 리팩토링

**문제점 및 안정성 영향:**
하나의 함수나 메서드가 너무 많은 작업을 수행하거나 지나치게 길어지면 다음과 같은 안정성 문제를 야기할 수 있습니다.
- **버그 잠재성 증가:** 코드가 복잡해질수록 논리적인 오류가 숨어있을 가능성이 커집니다.
- **단위 테스트의 어려움:** 특정 기능 단위로 테스트하기 어려워 코드의 정확성을 검증하기 힘듭니다.
- **디버깅의 복잡성:** 오류 발생 시 원인을 추적하고 수정하는 과정이 복잡하고 오래 걸립니다.
- **유지보수의 어려움:** 작은 변경사항이 예상치 못한 부분에 영향을 미칠 수 있어 코드 수정이 위험해집니다.

**구체적인 대상:**
- **`strategy.py` - `process_strategy` 메서드:** 다양한 매매 상태(WAITING, BOUGHT, PARTIAL_SOLD)에 따른 조건 판단 및 주문 실행 로직이 집중되어 매우 복잡합니다. 손절, 익절, 트레일링 스탑 등 여러 하위 로직이 얽혀 있습니다.
- **`strategy.py` - `on_chejan_data_received` 메서드:** 체결/잔고 데이터(`gubun`) 및 주문 상태에 따라 분기되는 로직이 길고, 포트폴리오 업데이트, DB 기록 등 다수의 작업을 수행합니다.
- **`kiwoom_api.py` - `on_receive_tr_data` 메서드:** 여러 TR 코드(`opt10081`, `opt10001`, `opw00001`, `opw00018` 등)에 대한 응답 처리가 단일 메서드에 집중되어 있습니다.
- **`kiwoom_api.py` - `comm_rq_data` 메서드:** TR 요청 전처리(화면번호, 간격 조절, ATS 입력값 설정), API 호출, 이벤트 루프 관리 등 많은 책임을 가지고 있습니다.

**개선 방안:**
- **단일 책임 원칙(SRP) 적용:** 각 함수/메서드는 하나의 명확한 책임만 갖도록 분리합니다.
    - `process_strategy`: 상태별 처리 함수(`_handle_waiting_state`, `_handle_holding_state`) 및 조건별 판단 함수(`_check_stop_loss`, `_check_profit_taking`)로 분리.
    - `on_chejan_data_received`: `gubun` 값 및 주문 상태에 따른 처리기(`_handle_chejan_execution_report`, `_process_order_filled`)로 분리.
    - `on_receive_tr_data`: TR 코드와 처리 메서드를 매핑하는 딕셔너리(`self.tr_handlers`)를 사용하고, 각 TR 코드별로 별도의 처리 메서드(`_handle_opt10081`, `_handle_opt10001` 등)를 구현.
    - `comm_rq_data`: ATS 관련 입력값 준비 로직, 캐시 설정 로직 등을 별도 헬퍼 함수로 분리.

**기대 효과 (안정성 측면):**
- **버그 발생 가능성 감소:** 각 함수가 단순해져 논리 오류를 줄일 수 있습니다.
- **테스트 용이성 향상:** 개별 기능 단위로 테스트가 가능해져 코드의 신뢰도를 높일 수 있습니다.
- **디버깅 효율 증대:** 오류 발생 시 문제 범위를 좁히기 쉬워 신속한 원인 파악 및 수정이 가능합니다.
- **유지보수성 향상:** 코드 수정 시 영향 범위를 명확히 알 수 있어 안정적인 변경이 가능합니다.

### 2.2. `TradingStrategy` 클래스의 많은 인스턴스 속성 관리 개선

**문제점 및 안정성 영향:**
하나의 클래스가 너무 많은 인스턴스 속성(변수)을 가지게 되면 다음과 같은 문제가 발생할 수 있습니다.
- **상태 관리의 복잡성 증가:** 클래스의 전체 상태를 이해하고 추적하기 어려워집니다.
- **예상치 못한 부수 효과(Side Effects) 발생 가능성:** 하나의 속성 변경이 다른 여러 속성이나 로직에 의도치 않은 영향을 줄 수 있습니다.
- **응집도 저하:** 서로 관련성이 낮은 데이터들이 하나의 클래스에 섞여 있어 코드 구조가 불명확해집니다.

**구체적인 대상:**
- **`strategy.py` - `TradingStrategy` 클래스:**
    - 종목별 전략 상태 추적 딕셔너리들 (`strategy_state`, `buy_prices`, `high_prices`, `order_sent_flags` 등)
    - 외부 의존성 객체, 계좌/종목 데이터, 운영 플래그, 설정값 등 다수가 직접적인 인스턴스 속성으로 존재합니다.

**개선 방안:**
- **데이터 클래스 또는 상태 객체 활용:**
    - **종목별 전략 상태 캡슐화:** 특정 종목에 대한 상태 정보들(`current_trading_state`, `buy_price`, `current_high_price`, `order_sent_rq_name` 등)을 `StockTradingStateInfo`와 같은 별도의 데이터 클래스로 정의합니다. `TradingStrategy`는 `stock_strategy_infos: Dict[str, StockTradingStateInfo]` 형태로 종목 코드별 상태 객체를 관리합니다.
    - **관련 설정 그룹화:** 전략 설정값들을 별도의 데이터 클래스나 딕셔너리로 묶어 관리하여 명확성을 높입니다 (예: `self.strategy_parameters`).

**기대 효과 (안정성 측면):**
- **상태 변경 추적 용이:** 종목별 상태가 명확한 객체로 관리되어 특정 종목의 상태 변화를 추적하고 디버깅하기 쉬워집니다.
- **코드의 예측 가능성 증대:** 관련된 데이터가 하나의 객체로 묶여 관리되므로, 특정 기능 수정 시 영향을 받는 범위를 예측하기 용이해집니다.
- **오류 발생 범위 축소:** 상태 변경이 특정 객체 내로 제한되어 예기치 않은 부수 효과 발생 가능성을 줄입니다.

### 2.3. 명시적 `else` 사용 및 오류 처리 강화

**문제점 및 안정성 영향:**
- **코드 흐름의 모호성:** `if`문 이후 `else` 없이 다음 로직으로 이어지거나 조건이 만족되지 않을 때 아무런 처리가 없으면, 코드의 모든 실행 경로가 명확하게 드러나지 않을 수 있습니다.
- **예상치 못한 조건/상태 누락 가능성:** 개발자가 의도하지 않은 조건이나 상태가 발생했을 때 이를 감지하지 못하고 넘어가 시스템이 불안정해질 수 있습니다.
- **불충분한 오류 로깅:** 오류 발생 시 원인 파악에 필요한 정보가 부족하여 디버깅이 어려워지고 문제 해결이 지연될 수 있습니다.

**구체적인 대상:**
- `strategy.py`의 `process_strategy`에서 다양한 상태 분기 시, 특정 상태가 아닌 경우에 대한 처리가 명시적이지 않을 수 있습니다.
- `kiwoom_api.py`의 `on_receive_tr_data`에서 예상치 못한 TR 코드 수신 시 처리.
- 전반적인 API 호출 결과에 대한 오류 코드 및 메시지 로깅 강화.

**개선 방안:**
- **명시적 `else pass`:** 의도적으로 아무 작업도 하지 않는 경우 `else: pass`를 추가하여 코드의 의도를 명확히 합니다.
- **예상치 못한 경로에 대한 로깅:** `if/elif` 문의 마지막에 `else` 블록을 추가하여, 예상하지 못한 조건이나 상태가 발생했을 때 경고 또는 오류 로그를 남겨 문제를 즉시 인지할 수 있도록 합니다.
    - 예시 (`process_strategy`):
      ```python
      if current_state == self.TradingState.WAITING:
          # ...
      elif current_state == self.TradingState.BOUGHT or current_state == self.TradingState.PARTIAL_SOLD:
          # ...
      elif current_state in [self.TradingState.IDLE, self.TradingState.COMPLETE]:
          pass # 의도적으로 아무것도 안 함
      else:
          self.log(f"{code} 알 수 없는 전략 상태: {current_state}. 확인 필요.", "WARNING")
      ```
- **오류/예외 상황 상세 로깅:** API 호출 실패 시 반환되는 오류 코드와 메시지, 관련 파라미터 등을 상세히 로깅하여 원인 분석을 용이하게 합니다. `try-except` 블록을 적절히 사용하여 예외 발생 시에도 프로그램이 비정상 종료되지 않고, 해당 상황을 기록한 후 안정적으로 다음 작업을 시도하거나 안전하게 종료할 수 있도록 합니다.

**기대 효과 (안정성 측면):**
- **코드의 모든 실행 경로 명확화:** 시스템의 동작을 더 쉽게 예측할 수 있게 됩니다.
- **잠재적 오류 조기 발견:** 예상치 못한 상황 발생 시 로그를 통해 빠르게 인지하고 대응할 수 있습니다.
- **시스템 견고성 향상:** 예외 상황에 대한 처리가 강화되어 부분적인 문제 발생 시 전체 시스템의 중단 가능성을 낮춥니다.
- **신속한 문제 해결:** 상세한 로그는 오류 발생 시 원인 파악 시간을 단축시켜 빠른 복구를 가능하게 합니다.

### 2.4. 주석 처리된 코드 정리

**문제점 및 안정성 영향:**
- **코드 혼란 야기 및 가독성 저해:** 오래되거나 더 이상 사용되지 않는 주석 처리된 코드는 현재 코드의 흐름을 이해하는 데 방해가 됩니다.
- **오해 유발 가능성:** 주석 처리된 코드가 현재 로직과 관련된 것처럼 보여 개발자에게 혼란을 줄 수 있으며, 이는 잘못된 수정으로 이어질 수 있습니다.
- **유지보수 부담 증가:** 불필요한 코드는 코드베이스를 무겁게 만들고, 향후 리팩토링이나 기능 추가 시 고려해야 할 대상을 늘립니다.

**구체적인 대상:**
- `main.py`: `exit_flag`, 로그 디렉토리 생성 코드 주석.
- `kiwoom_api.py`: `self.default_market_code_api` 주석, `__main__` 블록 내 테스트 코드.
- `strategy.py`: 시그널 연결 관련 코드 주석, 디버깅용 상세 로그 주석.

**개선 방안:**
- **완전히 불필요한 코드 삭제:** 더 이상 사용되지 않고 재사용 가능성이 낮은 주석 코드는 과감히 삭제합니다.
- **테스트/디버깅용 코드 분리:** `__main__` 블록의 테스트 코드는 `tests/` 디렉토리로 옮기거나, 특정 조건(예: 디버그 모드 플래그)에서만 실행되도록 변경합니다.
- **조건부 로깅 활용:** 디버깅용 상세 로그는 주석 처리하는 대신, 로거의 레벨 설정을 통해 제어하거나 `if self.logger.isEnabledFor(logging.DEBUG):`와 같이 조건부로 실행되도록 하여 실제 운영 코드에서는 불필요한 로그가 남지 않도록 합니다.

**기대 효과 (안정성 측면):**
- **코드베이스 청결도 향상:** 현재 유효한 코드에만 집중할 수 있어 오해로 인한 버그 발생 가능성을 줄입니다.
- **유지보수 효율성 증대:** 코드 변경 시 불필요한 부분을 고려하지 않아도 되므로 작업 효율이 높아지고, 실수로 인한 오류 가능성이 감소합니다.
- **새로운 개발자의 빠른 코드 이해:** 깨끗한 코드는 프로그램의 구조와 로직을 더 쉽게 파악할 수 있도록 도와줍니다.

## 3. 결론

위에 제안된 개선 방안들은 자동매매 프로그램의 안정성을 크게 향상시키는 데 기여할 것입니다. 코드의 복잡성을 낮추고, 각 부분의 책임을 명확히 하며, 오류 처리와 로깅을 강화함으로써 예기치 않은 문제 발생 시에도 시스템이 견고하게 동작하고, 문제 해결을 신속하게 할 수 있는 기반을 마련할 수 있습니다.

이러한 개선 작업은 단기적으로는 노력이 필요하지만, 장기적으로는 더욱 신뢰할 수 있고 관리하기 쉬운 시스템을 구축하는 데 필수적입니다.
