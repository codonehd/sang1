# 개발룰북 (Development Rulebook)

## 1. 기본 원칙

### 1.1 언어 사용
- **모든 응답은 한국어로 작성**
- 기술 문서, 코드 주석, 변수명은 영어 사용 가능하지만 설명은 한국어로

### 1.2 도구 사용 우선순위
- **MCP Tool 사용 조건**: MCP Tool 사용 권장
- **기본 도구 우선 사용**: MCP Tool 사용 불가 시 기본 도구 사용
- **절대경로 사용**: MCP Tool 사용시 절대경로 사용 권장

## 2. 프로젝트 분석 방법론

### 2.1 문서 기반 학습 순서
1. **프로젝트 개요 문서 우선 분석**
   - 시스템 구조 파악
   - 핵심 기능 이해
   - 데이터 흐름 분석

2. **실제 구현 코드 분석**
   - 개요 문서를 기준으로 구현상태 확인
   - 기능별 구현 완성도 평가
   - 미구현 부분 식별

### 2.2 코드 분석 체크리스트
- [ ] 핵심 클래스 구현 상태
- [ ] 메서드별 기능 구현 완성도
- [ ] 예외 처리 구현 여부
- [ ] 로깅 시스템 적용 상태
- [ ] 설정 관리 시스템 연동
- [ ] 데이터베이스 연동 상태

## 3. 자동 매매 시스템 개발 가이드

### 3.1 시스템 구조 요구사항
- **모듈화 설계**: 각 기능별 독립적인 모듈 구성
- **설정 관리**: 외부 JSON 파일을 통한 설정 관리
- **로깅 시스템**: 모든 중요 이벤트 로깅
- **데이터베이스**: SQLite 기반 데이터 저장
- **안전 종료**: Graceful shutdown 구현

### 3.2 핵심 모듈
```
main.py         # 진입점
config.py       # ConfigManager 클래스
logger.py       # Logger 클래스  
database.py     # Database 클래스
kiwoom_api.py   # KiwoomAPI 클래스
strategy.py     # TradingStrategy 클래스
util.py         # 유틸리티 함수들
```

### 3.3 데이터베이스 테이블 구조
- `watchlist`: 관심종목 관리
- `trades`: 매매 기록
- `decisions`: 매매 결정 로그
- `daily_snapshots`: 일일 스냅샷
- `ohlcv_data`: OHLCV 데이터

## 4. 코드 품질 기준

### 4.1 코딩 스타일
- **클래스명**: PascalCase (예: ConfigManager, TradingStrategy)
- **메서드명**: snake_case (예: load_config, execute_trade)
- **상수명**: UPPER_SNAKE_CASE (예: API_TIMEOUT, MAX_RETRY)
- **파일명**: snake_case (예: kiwoom_api.py, project_overview.md)

### 4.2 문서화 요구사항
- **클래스 독스트링**: 클래스 목적과 주요 기능 설명
- **메서드 독스트링**: 매개변수, 반환값, 예외 처리 설명
- **인라인 주석**: 복잡한 로직에 대한 설명

### 4.3 예외 처리
- **API 연결 실패**: 재시도 로직 구현
- **네트워크 타임아웃**: 적절한 타임아웃 설정
- **데이터 유효성**: 입력 데이터 검증
- **로깅**: 모든 예외 상황 로깅

## 5. 매매 전략 구현 가이드

### 5.1 상태 관리
- **TradingState enum**: 매매 상태 관리
- **StockTrackingData**: 종목별 추적 데이터
- **실시간 데이터 처리**: 효율적인 데이터 업데이트

### 5.2 안전성 확보
- **부분 체결 처리**: 미체결 수량 관리
- **잔고 확인**: 매수 전 잔고 검증
- **리스크 관리**: 손절매, 익절매 로직
- **화면 번호 관리**: API 호출 최적화

## 6. 개발 프로세스

### 6.1 분석 단계
1. 프로젝트 개요 문서 정독
2. 기존 코드 구조 파악
3. 구현 상태 점검
4. 미구현 기능 식별

### 6.2 구현 단계
1. 핵심 클래스부터 구현
2. 단위 기능별 순차 개발
3. 통합 테스트 수행
4. 로깅 및 예외 처리 보완

### 6.3 검증 단계
1. 기능별 동작 확인
2. 예외 상황 테스트
3. 성능 최적화
4. 문서 업데이트

## 7. 파일 관리 규칙

### 7.1 파일 접근
- **인코딩**: UTF-8 사용
- **백업**: 중요 파일 변경 전 백업

### 7.2 설정 파일
- **JSON 형식**: settings.json 사용
- **구조화**: 계층적 설정 구조
- **버전 관리**: 설정 변경 이력 관리

## 8. 도구 사용 가이드

### 8.1 기본 도구 (MCP Tool 실패 시)
- `read_file`: 파일 내용 읽기
- `edit_file`: 파일 편집
- `codebase_search`: 코드 검색

### 8.2 MCP Tools (MCP Tool 우선 사용, MCP Tool 사용시 절대경로 사용)
- 절대경로 사용 예시: `C:\python\sang1\strategy.py`
- `mcp_filesystem_read_file`: 파일 읽기
- `mcp_filesystem_write_file`: 파일 작성
- `mcp_filesystem_edit_file`: 파일 편집

## 9. 주의사항

### 9.1 보안
- **API 키 관리**: 설정 파일에서 분리
- **로그 정보**: 민감 정보 로깅 금지
- **권한 관리**: 최소 권한 원칙

### 9.2 성능
- **메모리 관리**: 불필요한 데이터 정리
- **API 호출**: 호출 빈도 최적화
- **데이터베이스**: 효율적인 쿼리 사용

## 10. AI 어시스턴트 협업 가이드 (2024년 12월 추가)

### 10.1 AI 어시스턴트 활용 시 기본 원칙

#### 10.1.1 사전 정보 제공
- **프로젝트 상태 명확화**: AI가 현재 프로젝트를 얼마나 파악하고 있는지 확인
- **수정 이력 공유**: 최근 변경사항과 그 결과 명시
- **문제 상황 구체화**: 발생한 오류의 정확한 상황과 로그 제공

#### 10.1.2 협업 흐름 관리
- **단계적 진행**: 분석 → 합의 → 수정 → 검증 순서 준수
- **사전 승인**: 코드 수정 전 반드시 사용자 확인 필요
- **영향도 분석**: 수정이 다른 기능에 미칠 영향 사전 검토

### 10.2 금지사항 (AI 어시스턴트 대상)

#### 10.2.1 무분별한 코드 수정 금지
- **증상 위주 수정 금지**: 눈에 보이는 오류만 고치는 접근 방식 금지
- **기존 기능 파괴 금지**: 잘 작동하던 기능을 모르게 변경하지 말 것
- **다중 수정 금지**: 한 번에 여러 기능을 동시에 수정하지 말 것
- **예상 기반 수정 금지**: 추측이나 예상으로 코드 구현하지 말 것

#### 10.2.2 잘못된 분석 방식 금지
- **단정적 결론 금지**: "이것이 문제다"라고 성급하게 결론내리지 말 것
- **표면적 분석 금지**: 근본 원인 분석 없이 즉석 해결책 제시 금지
- **검증 없는 수정 금지**: 수정사항이 실제 문제 해결로 이어지는지 검토 없이 진행 금지

### 10.3 문제 해결 방법론

#### 10.3.1 근본 원인 분석 우선
```
1. 문제 현상 정확히 파악
2. 언제부터 발생했는지 시점 확인
3. 그 시점 전후 변경사항 분석
4. 실제 로직과 예상 로직의 차이 분석
5. 최소한의 수정으로 해결 가능한 방법 모색
```

#### 10.3.2 수정 전 필수 체크리스트
- [ ] 문제의 근본 원인을 정확히 파악했는가?
- [ ] 이 수정이 다른 잘 작동하는 기능에 영향을 주지 않는가?
- [ ] 최소한의 변경으로 문제를 해결할 수 있는가?
- [ ] 사용자가 수정 방향에 동의했는가?
- [ ] 수정 후 검증 방법이 명확한가?

### 10.4 협업 사례 연구

#### 10.4.1 잘못된 협업 사례 (2024년 12월)
**상황**: 044490 종목 중복 매수 문제 발생
```
❌ 잘못된 접근:
1. 상태 플래그 변경 누락이라고 성급히 결론
2. 해당 부분만 수정했으나 문제 지속
3. 추가 수정 시도로 기존 기능까지 파괴
4. 무한 수정 → 악화 → 롤백 반복

✅ 올바른 접근이었어야 할 방향:
1. 부분체결 로직 수정 전후 정확한 차이 분석
2. 중복 매수를 결정하는 실제 로직 파악
3. 상태 플래그 외의 다른 원인 검토
4. 최소 변경으로 근본 원인 해결
```

#### 10.4.2 교훈
- **상태 플래그 변경은 이미 잘 작동하던 기능이었음**
- **부분체결 로직 수정 과정에서 다른 기능이 손상된 것**
- **중복 매수 결정 로직이 상태 플래그가 아닐 가능성**
- **AI가 찾은 "문제"가 실제 해결책이 아닐 수 있음**

### 10.5 효과적인 협업을 위한 가이드라인

#### 10.5.1 사용자 측 가이드라인
- **현재 상황 명확히 제공**: 어떤 수정을 했고 어떤 결과가 나왔는지
- **제한사항 명시**: 테스트 불가능한 조건이나 환경적 제약
- **우선순위 제시**: 어떤 문제가 가장 중요한지
- **롤백 지점 명확화**: 언제 상태로 돌아가고 싶은지

#### 10.5.2 AI 어시스턴트 측 가이드라인
- **파악 수준 명시**: 현재 프로젝트를 얼마나 이해하고 있는지 솔직히 표현
- **불확실성 인정**: 모르는 부분이나 추측하는 부분 명확히 구분
- **단계적 접근**: 분석 → 합의 → 수정 단계를 명확히 구분
- **영향도 검토**: 수정이 다른 부분에 미칠 영향 사전 분석

### 10.6 성공적인 협업을 위한 체크포인트

#### 10.6.1 분석 단계
- [ ] AI가 현재 상황을 정확히 파악했는가?
- [ ] 문제의 근본 원인에 대한 합의가 이루어졌는가?
- [ ] 수정 방향에 대한 양측 동의가 있는가?

#### 10.6.2 수정 단계  
- [ ] 최소한의 변경으로 진행하는가?
- [ ] 기존 잘 작동하는 기능에 영향이 없는가?
- [ ] 수정 후 검증 방법이 준비되어 있는가?

#### 10.6.3 검증 단계
- [ ] 의도한 문제가 실제로 해결되었는가?
- [ ] 새로운 문제가 발생하지 않았는가?
- [ ] 관련 기능들이 여전히 정상 동작하는가?

## 11. 매매 시스템 핵심 로직 (2024년 12월 추가)

### 11.1 중복 매수 방지 시스템

#### 11.1.1 3단계 방어 시스템
```
1차 방어: 포트폴리오 보유량 확인 (_handle_waiting_state)
 - 실제 계좌 포트폴리오에서 보유수량 확인
 - 0보다 크면 매수 차단

2차 방어: 매수 체결 횟수 확인 (execute_buy)
 - stock_info.buy_completion_count 확인
 - max_buy_attempts_per_stock 설정값과 비교

3차 방어: 상태 플래그 확인 (execute_buy)
 - TradingState.BOUGHT, PARTIAL_SOLD, COMPLETE 상태 확인
 - 해당 상태시 매수 차단
```

#### 11.1.2 매수 체결 완료 시점 정의
**중요**: `buy_completion_count`는 **완전체결 시에만** 증가
```python
# ✅ 올바른 구현 (strategy.py)
if stock_info.strategy_state != TradingState.BOUGHT:
    stock_info.buy_completion_count += 1  # 첫 매수 체결시에만 증가
    stock_info.strategy_state = TradingState.BOUGHT
```

### 11.2 StockTrackingData 일관성 확보

#### 11.2.1 종목코드 정규화 규칙
```python
def _normalize_stock_code(self, code):
    """A접두사 제거 정규화"""
    if not code:
        return ""
    normalized = str(code).strip()
    if normalized.startswith('A') and len(normalized) > 1:
        normalized = normalized[1:]
    return normalized
```

#### 11.2.2 정규화 적용 지점
- **저장 시**: `add_to_watchlist()` - 입력 코드 정규화 후 저장
- **체결 데이터 처리**: `on_chejan_data_received()` - 정규화 후 검색
- **전략 실행**: `process_strategy()` - 정규화된 코드로 검색

#### 11.2.3 StockTrackingData 접근 실패 대응
```python
# 1단계: 정규화된 코드로 재검색
if not stock_info and code != normalized_code:
    stock_info = self.watchlist.get(normalized_code)

# 2단계: 포트폴리오에서 자동 복구
if not stock_info:
    stock_info = self._recover_missing_stock_from_portfolio(code)

# 3단계: 긴급 중복매수 차단
if not stock_info and code in portfolio and holding_quantity > 0:
    self.log("EMERGENCY_STOP: StockTrackingData 없지만 포트폴리오 보유", "CRITICAL")
    return  # 매수 차단
```

### 11.3 부분체결 처리 규칙

#### 11.3.1 미체결 수량 기반 체결량 계산
```python
# ❌ 잘못된 방식 (FID 911 사용)
last_filled_qty = self._safe_to_int(chejan_data.get("911"))

# ✅ 올바른 방식 (미체결량 차이 계산)
previous_unfilled_qty = active_order_entry_ref.get('unfilled_qty', original_order_qty)
current_unfilled_qty = unfilled_qty  # FID 902
last_filled_qty = previous_unfilled_qty - current_unfilled_qty
```

#### 11.3.2 임시 주문 수량 관리
- **매도 주문 접수시**: 포트폴리오 임시 주문 수량 증가
- **부분 체결시**: 체결량만큼 임시 주문 수량 감소
- **주문 완료시**: 임시 주문 수량 완전 초기화

### 11.4 상태 전이 규칙

#### 11.4.1 TradingState 전이도
```
WAITING → BOUGHT (첫 매수 체결시)
BOUGHT → PARTIAL_SOLD (부분 매도시)
PARTIAL_SOLD → BOUGHT (잔량 유지시)
BOUGHT/PARTIAL_SOLD → WAITING (전량 매도시, reset_stock_strategy_info 호출)
Any → COMPLETE (최대 시도 횟수 도달시)
```

#### 11.4.2 상태별 처리 로직
- **WAITING**: 매수 조건 확인 및 매수 실행
- **BOUGHT**: 매도 조건 확인 (손절, 익절, 트레일링 스탑)
- **PARTIAL_SOLD**: 잔량에 대한 매도 조건 확인
- **COMPLETE**: 더 이상 매수 시도 없음

### 11.5 개발 시 필수 검증 사항

#### 11.5.1 코드 수정 전 체크리스트
- [ ] 수정이 3단계 중복매수 방지 시스템을 파괴하지 않는가?
- [ ] StockTrackingData 접근 로직의 일관성이 유지되는가?
- [ ] 종목코드 정규화가 모든 관련 함수에 적용되었는가?
- [ ] 매수 체결 완료 카운팅 로직이 올바른가?

#### 11.5.2 매매 로직 변경 시 특별 주의사항
- **절대 원칙**: 잘 작동하는 중복매수 방지 로직 건드리지 말 것
- **검증 필수**: 포트폴리오와 StockTrackingData 동기화 확인
- **테스트 항목**: 부분체결, 완전체결, 매수실패 시나리오 모두 확인

## 12. 중복 매수 문제 해결 사례 (2024년 12월)

### 12.1 문제 상황
- **증상**: 044490 종목 등에서 4회 중복 매수 발생
- **원인**: "StockTrackingData가 작동에 실패했다" 로그 반복 확인
- **결과**: 중복매수 방지 시스템 전체 우회

### 12.2 근본 원인 분석
#### 12.2.1 StockTrackingData 접근 실패
```python
# 문제점: process_strategy에서 early return
def process_strategy(self, code):
    stock_info = self.watchlist.get(code)
    if not stock_info:
        # ⚠️ 여기서 return되면 모든 중복매수 방지 로직 우회!
        return
    # ... 실제 매수 방지 로직들
```

#### 12.2.2 종목코드 정규화 불일치
- **체결 데이터**: 'A005930' 형태로 수신
- **watchlist 저장**: '005930' 형태로 저장
- **결과**: 코드 매칭 실패로 StockTrackingData 접근 불가

### 12.3 해결책 적용
1. **종목코드 정규화 통일**: 모든 지점에서 `_normalize_stock_code()` 사용
2. **StockTrackingData 복구 로직**: 포트폴리오 기반 자동 복구
3. **긴급 차단 로직**: StockTrackingData 실패 시에도 중복매수 차단
4. **상세 로깅**: 실패 원인 추적을 위한 디버깅 정보 추가

### 12.4 예방책
- **일관성 검증**: 종목코드 정규화 로직 통일성 확인
- **접근 실패 모니터링**: StockTrackingData 접근 실패 빈도 추적
- **포트폴리오 동기화**: watchlist와 portfolio 간 동기화 확인

## 13. 협업 시 추가 지침

### 13.1 중요한 깨달음
1. **"실패하지 않도록 수정"이 우선**: 증상 치료보다 근본 원인 해결
2. **매수 체결 완료 시점 이해**: buy_completion_count는 완전체결시에만 증가
3. **종목코드 일관성**: 모든 지점에서 동일한 정규화 로직 적용

### 13.2 향후 개발 원칙
- **기존 작동 로직 보존**: 잘 작동하는 중복매수 방지 시스템 절대 건드리지 말 것
- **단계적 검증**: 수정 → 검증 → 다음 수정 순서 엄격히 준수
- **영향도 분석 필수**: 모든 수정이 다른 기능에 미치는 영향 사전 검토

---

*이 협업 가이드는 실제 경험을 바탕으로 작성되었으며, 지속적으로 개선될 예정입니다.*

---

*이 룰북은 프로젝트 진행에 따라 지속적으로 업데이트됩니다.*