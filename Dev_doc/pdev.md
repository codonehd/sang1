# **키움 OpenAPI+ 자동매매 프로그램 개선 프로젝트 관리 문서**

## **1\. 프로젝트 개요**

### **1.1. 프로젝트 목표**

본 프로젝트는 현재 개발된 키움 OpenAPI+ 기반 콘솔 자동매매 프로그램의 안정성을 확보하고, 핵심 기능을 개선하며, 매매 전략을 정교화하여 사용자 요구사항에 부합하는 신뢰도 높은 자동매매 시스템을 구축하는 것을 목표로 합니다.

### **1.2. 주요 개선 방향**

* **안정성 최우선**: GUI 잔재 제거, API 통신 안정화, 철저한 예외 처리를 통해 프로그램의 장시간 안정적 운영을 보장합니다.  
* **매매 로직 정교화**: 사용자 정의 매수 전략을 정확히 구현하고, 손절 및 익절, 트레일링 스탑 로직을 보완합니다.  
* **테스트 환경 개선**: 콘솔 환경에서의 모의투자 테스트 효율성을 높이기 위한 "Dry Run" 모드 및 상세 로깅 기능을 구현합니다.  
* **사용자 설정 및 관리 용이성 증대**: 설정 파일 유효성 검사, 데이터베이스 활용 확대를 통해 관리 편의성을 높입니다.  
* **ATS 환경 대응**: 대체거래소(NXT, ALL) 환경에서의 기본적인 시세 조회 및 주문 기능을 지원합니다.

## **2\. 마일스톤 및 태스크 정의**

### **마일스톤 1: 코어 시스템 안정화 및 기반 다지기**

* **목표**: 프로그램의 불필요한 요소를 제거하고, 기본적인 API 통신 및 로깅, 설정 관리의 안정성을 확보합니다.  
* **예상 기간**: (사용자 설정 필요)

**태스크 1.1: GUI 잔재 코드 완전 제거**

* **설명**: ui.py 파일 및 다른 모듈에 남아있는 PyQt5 관련 코드(시그널, 슬롯, 위젯 등)를 완전히 제거하여 콘솔 환경에 최적화합니다.  
* **완료 기준 (Definition of Done)**:  
  * ui.py 파일 삭제 또는 모든 내용 주석 처리.  
  * strategy.py, main.py 등에서 pyqtSignal, emit 등 GUI 관련 코드 모두 제거 확인.  
  * 프로그램 실행 시 GUI 관련 오류 또는 경고 메시지 미발생.  
* **실행 프롬프트 (ChatGPT 지시용)**:  
  프로젝트의 파이썬 코드 전체에서 PyQt5 관련 GUI 잔재 코드를 제거해주세요. 대상 파일은 \`ui.py\`, \`strategy.py\`, \`main.py\` 등이며, 특히 다음 사항들을 확인하고 제거해야 합니다:  
  1\.  \`ui.py\` 파일의 모든 클래스 및 함수 (파일 자체를 삭제해도 무방하나, 다른 곳에서 참조하는 유틸리티 함수가 있다면 해당 함수는 \`util.py\` 등으로 이동).  
  2\.  다른 파이썬 파일(\`.py\`) 내에 정의된 \`pyqtSignal\` 객체 및 해당 객체의 \`.emit()\` 메소드 호출 부분.  
  3\.  PyQt5 관련 모듈 import 구문 (예: \`from PyQt5.QtCore import pyqtSignal\`).  
  4\.  \`QApplication\` 인스턴스 생성 외의 GUI 화면 구성 및 표시와 관련된 모든 코드. (단, \`QApplication\`은 키움 API 이벤트 루프를 위해 필요하므로 \`main.py\`에 유지)  
  제거 후, 프로그램이 콘솔 환경에서 정상적으로 시작되고 핵심 기능(API 연결, 로깅 등)이 GUI 없이 동작하는지 확인해주세요.

**태스크 1.2: 기본 API 통신 안정화 (계좌정보, 기본 데이터 조회)**

* **설명**: 계좌 정보 조회(예: OPW00001), 관심종목 기본 정보 조회(OPT10001), 일봉 데이터 조회(OPT10081) 등 핵심적인 API TR 요청/응답 처리를 안정화합니다. 화면 번호 관리, TR 요청 간격, 오류 코드 처리 등을 점검하고 개선합니다.  
* **완료 기준**:  
  * 프로그램 시작 시 계좌 정보(예수금 등) 정상 조회 및 로깅.  
  * 관심종목에 대한 기본 정보(현재가, 시가, 전일종가 등) 정상 조회 및 로깅.  
  * 관심종목에 대한 최근 N일치 일봉 데이터 정상 조회 및 database.py를 통해 저장 (또는 메모리 내 저장).  
  * util.py의 ScreenManager가 모든 TR 요청/응답 과정에서 올바르게 사용(획득/반납)됨.  
  * API 요청 실패 시(반환값 \!= 0 또는 OnReceiveMsg로 오류 수신) 명확한 로그 기록 및 화면 번호 즉시 반납.  
  * 연속 조회(sPrevNext="2") 로직 정상 작동 확인.  
* **실행 프롬프트 (ChatGPT 지시용)**:  
  키움 OpenAPI+ 자동매매 프로그램의 API 통신 안정성을 개선해주세요. 대상 파일은 \`kiwoom\_api.py\`, \`util.py\` 입니다.  
  1\.  \`kiwoom\_api.py\`에서 다음 TR 요청 및 데이터 처리 로직을 점검하고 안정화해주세요:  
      \* 예수금 상세 현황 요청 (\`OPW00001\`): 로그인 후 자동으로 계좌 정보를 조회하고, 주요 정보(예: 예수금)를 로깅하도록 합니다.  
      \* 주식 기본 정보 요청 (\`OPT10001\`): 관심종목의 현재가, 시가, 전일종가 등을 정확히 파싱하고, \`strategy.py\`에서 사용할 수 있도록 \`stock\_data\` 딕셔너리 등에 저장/업데이트하는 로직을 확인합니다.  
      \* 주식 일봉 차트 조회 (\`OPT10081\`): 관심종목의 일봉 데이터를 N일치(예: 최근 60일) 조회하여 날짜, 시가, 고가, 저가, 종가, 거래량을 정확히 파싱하고, 연속 조회(\`sPrevNext\`) 처리가 올바르게 동작하는지 확인합니다. 조회된 데이터는 \`database.py\` 또는 내부 자료구조에 저장하도록 합니다.  
  2\.  모든 \`CommRqData\` 호출 전후로 \`util.py\`의 \`ScreenManager\`를 사용하여 화면 번호를 할당받고, \`OnReceiveTrData\` 또는 \`OnReceiveMsg\` (오류 발생 시) 이벤트 핸들러 내에서 해당 화면 번호를 반드시 반납하도록 로직을 철저히 검토 및 수정해주세요.  
  3\.  \`CommRqData\` 호출 시 반환값을 체크하여 0이 아닌 경우 에러 로그를 남기고 화면 번호를 즉시 반납하도록 수정해주세요.  
  4\.  \`OnReceiveMsg\` 이벤트 핸들러에서 API가 보내는 오류 메시지(예: "조회과다", "시세조회제한")를 로깅하고, 필요한 경우 프로그램 안정성을 위한 대응 로직(예: 잠시 후 재시도 또는 알림)을 추가하는 방안을 고려해주세요. (단, 재시도 로직은 이번 태스크에서 구현하지 않아도 되며, 로깅에 집중)  
  5\.  TR 요청 사이에 최소 0.2초의 간격을 두도록 \`time.sleep(0.2)\` 또는 \`non\_blocking\_sleep\_using\_process\_events(0.2)\` (현재 사용 중인 함수)가 적절히 사용되고 있는지 확인해주세요.  
  참고 문서: \`kiwoom\_openapi\_plus\_devguide\_ver\_1.1.pdf\`, \`\[붙임\]대체거래소(ATS) 도입에 따른 키움 Open API \+ 변경 안내\_ver20250303\_ver1.3.pdf\` (종목코드 접미사 관련)

**태스크 1.3: 설정 관리 강화 (config.py)**

* **설명**: settings.json 파일 로드 시 필수 설정값 누락, 데이터 타입 오류 등을 검증하는 로직을 ConfigManager에 추가합니다.  
* **완료 기준**:  
  * ConfigManager 초기화 시 settings.json의 주요 항목(계좌번호, 매수/매도 전략 관련 수치 등) 존재 여부 및 기본 타입(숫자, 문자열, 리스트 등) 유효성 검사 수행.  
  * 검증 실패 시 오류 로그 기록 및 프로그램 안전 종료 또는 기본값 사용 알림.  
* 실행 프롬프트 (ChatGPT 지시용):  
  \`\`\`config.py의 ConfigManager클래스를 수정하여settings.json\` 파일 로드 시 설정값 유효성 검사 기능을 추가해주세요.  
  1. \_\_init\_\_ 또는 별도 메소드 내에서 다음 항목들에 대한 유효성 검사를 수행합니다:  
     * account\_number: 문자열, 존재 여부.  
     * buy\_amount\_per\_stock: 숫자, 0보다 큰 값.  
     * target\_profit\_rate: 숫자, 0보다 큰 값.  
     * stop\_loss\_rate: 숫자, 0보다 큰 값.  
     * trailing\_stop\_fall\_rate: 숫자, 0보다 큰 값.  
     * buy\_sell\_target\_stocks: 리스트, 비어있지 않음 (선택 사항, 비어있을 수 있다면 해당 검증은 제외).  
     * (추가적으로 검증이 필요한 중요 설정값들)  
  2. 유효성 검사에 실패할 경우, logger를 사용하여 어떤 설정값이 왜 잘못되었는지 상세한 오류 메시지를 기록하고, 프로그램이 더 이상 진행되지 않도록 SystemExit 예외를 발생시키거나, 또는 명확한 경고 후 기본값을 사용하도록 처리해주세요. (사용자에게 질문: 오류 시 종료할까요, 아니면 기본값 사용 또는 경고만 할까요? 현재는 오류 시 종료로 가정합니다.)

\*\*사용자님께 질문\*\*: \`settings.json\` 유효성 검사 실패 시, 프로그램을 즉시 종료하는 것이 좋을까요, 아니면 오류를 기록하고 (가능하다면) 기본값을 사용하거나 사용자에게 경고만 하는 것이 좋을까요? (위 프롬프트는 '종료'로 가정했습니다.)

### **마일스톤 2: 매매 전략 구현 및 정교화**

* **목표**: 사용자 정의 매수 전략을 정확히 구현하고, 기존 매도 로직(손절, 익절, 트레일링 스탑)을 점검 및 보완합니다.  
* **예상 기간**: (사용자 설정 필요)

**태스크 2.1: 사용자 정의 매수 전략 구현 (strategy.py)**

* **설명**: "당일 시가가 전일 종가보다 높이 시작한 종목이, 장중 전일 종가를 하회했다가, 다시 전일 종가를 돌파하는 시점"에 매수하는 전략을 strategy.py에 구현합니다.  
* **완료 기준**:  
  * strategy.py 내 stock\_data 또는 유사한 자료구조에 종목별 '전일 종가', '당일 시가', '전일 종가 하회 여부' 상태 플래그 관리.  
  * 실시간 데이터 수신 시 위 상태 플래그들을 올바르게 업데이트.  
  * 매수 조건(시가 \> 전일종가, AND 전일종가 하회 이력 True, AND 현재가 \> 전일종가) 충족 시 매수 신호 발생 (execute\_buy 호출).  
  * 관련 로직에 대한 상세 주석 및 로그 기록.  
* 실행 프롬프트 (ChatGPT 지시용):  
  \`\`\`strategy.py의 TradingStrategy\` 클래스를 수정하여 다음의 사용자 정의 매수 전략을 구현해주세요.  
  매수 전략: "당일 시가가 전일 종가보다 높게 시작한 종목이, 장중 주가가 전일 종가 아래로 하락했다가, 이후 다시 전일 종가를 돌파하여 상승하는 시점에 매수한다."  
  1. self.stock\_data\[code\] 딕셔너리 (또는 유사한 종목별 데이터 저장 구조)에 다음 정보를 저장하고 관리하도록 추가/수정해주세요:  
     * yesterday\_close\_price (전일 종가)  
     * today\_open\_price (당일 시가)  
     * is\_yesterday\_close\_broken\_today (금일 장중 전일 종가를 하회한 적이 있는지 여부를 나타내는 boolean 플래그, 초기값 False)  
  2. 관심종목의 '전일 종가'와 '당일 시가'는 프로그램 시작 시 또는 장 시작 시 kiwoom\_api.py를 통해 조회하여 stock\_data에 업데이트해야 합니다. (이 부분은 태스크 1.2와 연계)  
  3. 실시간 데이터(주식 체결 정보 등)를 수신하는 메소드(예: handle\_real\_data 또는 update\_stock\_data\_realtime) 내에서 다음 로직을 구현해주세요:  
     * 해당 종목의 today\_open\_price가 yesterday\_close\_price보다 높은지 먼저 확인합니다. (이 조건이 만족되지 않으면 아래 로직 미실행)  
     * 만약 현재가가 yesterday\_close\_price 미만이고, is\_yesterday\_close\_broken\_today가 False이면, is\_yesterday\_close\_broken\_today를 True로 설정합니다. (로그: "\[종목코드\] 전일 종가 하회 기록")  
     * 만약 is\_yesterday\_close\_broken\_today가 True이고, 현재가가 yesterday\_close\_price를 초과하면 (즉, 전일 종가를 다시 돌파하면), 매수 조건을 충족한 것으로 간주하고 self.execute\_buy(code, current\_price)를 호출합니다. (로그: "\[종목코드\] 전일 종가 재돌파, 매수 조건 충족")  
     * 매수 주문 실행 후에는 해당 종목의 is\_yesterday\_close\_broken\_today 플래그를 다시 False로 리셋하거나, 또는 TradingState를 BOUGHT로 변경하여 중복 매수를 방지합니다.  
  4. 기존 check\_buy\_condition 메소드가 있다면, 이 새로운 전략 로직을 통합하거나 대체하도록 수정합니다.  
  5. 모든 로직 변경 사항에 대해 상세한 주석을 추가하고, 주요 상태 변화 및 결정 사항을 self.logger를 통해 기록해주세요.

**태스크 2.2: 매도 로직 점검 및 보완 (strategy.py)**

* **설명**: 기존 손절, 익절(1차 분할매도), 트레일링 스탑(잔량매도) 로직을 점검하고, 기준 가격(매수가, 고점 등) 추적 및 계산의 정확성을 높입니다.  
* **완료 기준**:  
  * 손절: on\_chejan\_data\_received에서 실제 체결된 '매수가'를 정확히 기록하고, 이를 기준으로 손절가 계산 및 매도 실행.  
  * 익절(1차): 설정된 수익률 도달 시 정확한 수량(설정된 비율)만큼 매도 실행. PARTIAL\_SOLD 상태로 정확히 전환.  
  * 트레일링 스탑:  
    * PARTIAL\_SOLD 상태 또는 BOUGHT 상태에서 (사용자 정책 확인 필요) 당일 누적 고점 또는 부분 매도 후 고점을 정확히 추적. (stock\_data\[code\]\['trailing\_start\_high'\] 등 활용)  
    * 추적된 고점 대비 설정된 하락률만큼 하락 시 잔량 전량 매도 실행.  
  * 모든 매도 조건 판단 및 실행 과정에 대한 상세 로그 기록.  
* 실행 프롬프트 (ChatGPT 지시용):  
  \`\`\`strategy.py의 TradingStrategy\` 클래스 내 매도 로직을 점검하고 보완해주세요.  
  1. **손절 로직**:  
     * on\_chejan\_data\_received 메소드에서 매수 체결 시, 실제 체결 가격(ev.체결가)과 체결 수량(ev.체결수량)을 self.stock\_data\[code\]에 정확히 저장하도록 합니다. (예: avg\_buy\_price, holding\_quantity)  
     * 실시간 가격 업데이트 시, 저장된 avg\_buy\_price와 self.config.get('stop\_loss\_rate')를 기준으로 손절 가격을 계산하고, 현재가가 손절 가격 이하로 내려가면 보유 수량 전량을 시장가로 매도(self.execute\_sell)하도록 합니다.  
  2. **익절 (1차 분할 매도) 로직**:  
     * 실시간 가격 업데이트 시, avg\_buy\_price와 self.config.get('target\_profit\_rate')를 기준으로 익절 목표가를 계산합니다.  
     * 현재가가 익절 목표가 이상 도달 시, self.config.get('partial\_sell\_ratio', 0.5) (기본 50%)에 해당하는 수량을 시장가로 매도합니다.  
     * 매도 후 self.stock\_data\[code\]\['state'\]를 TradingState.PARTIAL\_SOLD로 변경하고, holding\_quantity를 업데이트합니다.  
  3. **트레일링 스탑 (잔량 매도) 로직**:  
     * **고점 추적**:  
       * 종목 매수(BOUGHT 상태) 후 또는 1차 익절(PARTIAL\_SOLD 상태) 후, 해당 종목의 당일 고가(ev.고가 또는 실시간 데이터의 고가)를 self.stock\_data\[code\]\['trailing\_start\_high'\]와 같은 변수에 지속적으로 업데이트합니다. (사용자에게 질문: 트레일링 스탑은 1차 익절 후에만 발동되나요, 아니면 매수 직후부터 고점을 추적하여 발동될 수 있나요? 현재는 두 경우 모두 고점을 추적한다고 가정합니다.)  
     * **매도 조건**: 실시간 가격 업데이트 시, trailing\_start\_high 대비 self.config.get('trailing\_stop\_fall\_rate') 이상 하락하면, 현재 보유 중인 잔량(holding\_quantity) 전량을 시장가로 매도합니다.  
     * 매도 후 self.stock\_data\[code\]\['state'\]를 TradingState.COMPLETE (또는 TradingState.IDLE)로 변경합니다.  
  4. 모든 매도 조건 판단 및 주문 실행 과정에 대해 self.logger를 사용하여 상세한 로그(기준 가격, 현재가, 매도 수량 등)를 기록해주세요.

\*\*사용자님께 질문\*\*: 트레일링 스탑은 1차 익절(\`PARTIAL\_SOLD\` 상태) 이후에만 발동되도록 할까요, 아니면 종목을 매수한 직후(\`BOUGHT\` 상태)부터 고점을 추적하여 발동될 수 있도록 할까요? (위 프롬프트는 두 경우 모두 고점을 추적한다고 가정하고, 매도 조건에서 상태를 고려하도록 유도했습니다.)

### **마일스톤 3: 테스트 환경 개선 및 데이터 관리**

* **목표**: 콘솔 환경에서의 모의투자 테스트 효율성을 높이고, 거래 관련 데이터를 체계적으로 관리합니다.  
* **예상 기간**: (사용자 설정 필요)

**태스크 3.1: "Dry Run" (가상 매매) 모드 구현**

* **설명**: settings.json에 dry\_run\_mode 설정을 추가하고, 이 모드가 활성화되면 실제 주문 대신 로그만 기록하거나 내부적으로 가상 체결을 시뮬레이션합니다.  
* **완료 기준**:  
  * settings.json에 dry\_run\_mode: true/false 설정 추가 및 ConfigManager에서 로드.  
  * dry\_run\_mode가 true일 때, KiwoomAPI.send\_order 함수에서 실제 ocx.SendOrder() 호출을 건너뛰고, "Dry Run 주문: \[내용\]" 로그 기록.  
  * dry\_run\_mode가 true일 때, Strategy.on\_chejan\_data\_received를 가상으로 호출하여 매매 로직이 정상적으로 다음 상태로 넘어가는지 테스트 가능. (가상 체결 데이터 생성 필요)  
* **실행 프롬프트 (ChatGPT 지시용)**:  
  자동매매 프로그램에 "Dry Run" (가상 매매) 모드를 구현해주세요.  
  1\.  \`settings.json\` 파일에 \`dry\_run\_mode\` 항목을 추가하고 (기본값 \`false\`), \`config.py\`의 \`ConfigManager\`가 이 값을 읽어올 수 있도록 수정해주세요. (예: \`self.config.get('dry\_run\_mode', False)\`)  
  2\.  \`kiwoom\_api.py\`의 \`KiwoomAPI\` 클래스 내 \`send\_order\` 메소드를 수정합니다.  
      \* 메소드 시작 부분에서 \`if self.config.get('dry\_run\_mode'):\` 와 같이 확인합니다.  
      \* \`dry\_run\_mode\`가 \`True\`이면, 실제 \`self.ocx.SendOrder(...)\`를 호출하는 대신, 주문 관련 정보(종목코드, 주문유형, 수량, 가격, 매수/매도 구분 등)를 상세히 로깅합니다. (예: \`self.logger.info(f"\[Dry Run\] 주문 요청: {매개변수들}")\`)  
      \* 또한, \`dry\_run\_mode\`가 \`True\`일 때 \`send\_order\`가 가상의 주문번호(예: "DRYRUN\_0001")를 반환하도록 하고, \`strategy.py\`의 \`TradingStrategy\` 클래스에서 이 가상 주문에 대한 가상 체결 데이터를 생성하여 \`on\_chejan\_data\_received\`를 직접 호출하는 로직을 추가합니다. 이 가상 체결 데이터는 실제 체결 데이터 형식과 유사해야 하며, 주문한 수량만큼 즉시 전량 체결되었다고 가정할 수 있습니다. (체결 가격은 주문 가격 또는 현재가 사용)  
  3\.  \`strategy.py\`의 \`TradingStrategy\` 클래스에서 \`on\_chejan\_data\_received\`를 호출할 때, \`dry\_run\_mode\`를 고려하여 실제 체결 데이터와 가상 체결 데이터를 구분하여 처리할 수 있도록 합니다 (필요한 경우).

**태스크 3.2: 상세 로깅 및 상태 주기적 출력/로깅**

* **설명**: 매매 결정 과정, 주문/체결 상세 정보, 포트폴리오 변화 등을 logger.py를 통해 더욱 상세히 기록하고, 주요 상태 정보를 주기적으로 콘솔에 출력하거나 파일에 로깅합니다.  
* **완료 기준**:  
  * 매수/매도 결정 시 판단 근거가 된 조건 및 데이터 값 상세 로깅.  
  * 주문 요청 시 모든 파라미터 로깅, 체결 데이터 수신 시 모든 필드 상세 로깅.  
  * main.py 또는 Strategy 내에 QTimer 등을 활용하여 일정 간격(예: 1분)으로 현재 보유 종목, 평가손익, 예수금, 각 관심종목의 TradingState 등을 로깅 또는 콘솔 출력.  
* **실행 프롬프트 (ChatGPT 지시용)**:  
  프로그램의 로깅 기능을 강화하고, 주요 상태 정보를 주기적으로 출력/로깅하는 기능을 추가해주세요.  
  1\.  \*\*상세 로깅 강화 (\`strategy.py\`, \`kiwoom\_api.py\`)\*\*:  
      \* \`strategy.py\`의 매수/매도 조건 판단 로직(\`check\_buy\_condition\`, \`check\_sell\_condition\` 또는 실시간 데이터 처리 부분)에서 어떤 데이터(예: 현재가, 이동평균선 값, 전일종가, 고가 등)와 어떤 설정값(예: 익절률, 손절률)을 비교하여 의사결정을 내렸는지 구체적으로 로깅해주세요.  
      \* \`kiwoom\_api.py\`의 \`send\_order\` 호출 시 전달되는 모든 인자 값을 로깅해주세요.  
      \* \`on\_chejan\_data\_received\` 이벤트 핸들러에서 수신하는 체결 데이터(\`OP\_CODE\`, \`매매구분\`, \`종목코드\`, \`체결수량\`, \`체결가격\`, \`주문번호\` 등)의 주요 필드를 모두 로깅해주세요.  
  2\.  \*\*주기적 상태 보고 (\`main.py\` 또는 \`strategy.py\`)\*\*:  
      \* \`QTimer\`를 사용하여 (예: 60초 간격) 다음 정보를 주기적으로 \`logger.info\` 또는 \`print\`를 통해 출력/로깅하는 함수를 작성하고 \`main.py\`에서 실행시켜주세요:  
          \* 현재 시간  
          \* 예수금 (조회 가능 시)  
          \* 총 평가금액, 총 평가손익 (조회 가능 시)  
          \* 보유 중인 각 종목의 정보: 종목코드, 종목명, 보유수량, 평균단가, 현재가, 평가손익, 수익률  
          \* \`strategy.py\`의 \`stock\_data\`에 있는 각 관심 종목의 현재 \`TradingState\`.  
      \* 이 기능은 \`settings.json\`의 설정값으로 활성화/비활성화 및 주기 변경이 가능하도록 하면 더욱 좋습니다 (선택 사항).

**태스크 3.3: 데이터베이스 활용 확대 (database.py)**

* **설명**: 거래 내역(체결 기준), 매매 결정 근거, 일별 계좌 상태 스냅샷 등을 SQLite 데이터베이스에 기록하여 분석 및 추적 용이성을 높입니다.  
* **완료 기준**:  
  * database.py에 거래 내역(종목코드, 매수/매도, 체결시간, 체결가, 체결수량, 수수료, 세금 등) 저장 함수 구현.  
  * strategy.py의 on\_chejan\_data\_received에서 체결 완료 시 위 함수 호출하여 DB에 기록.  
  * (선택) 매수/매도 결정 시 주요 판단 근거(당시 주가, 지표 값 등)를 별도 테이블에 기록.  
  * (선택) 매일 장 마감 시 예수금, 총자산 등을 스냅샷으로 DB에 저장하는 기능.  
* 실행 프롬프트 (ChatGPT 지시용):  
  \`\`\`database.py의 Database\` 클래스를 확장하여 거래 관련 데이터를 SQLite DB에 저장하는 기능을 강화해주세요.  
  1. **거래 내역 테이블 스키마 정의 및 생성**:  
     * trades 테이블 (예시): id (PK, 자동증가), order\_no (주문번호), timestamp (체결시간, TEXT), stock\_code (종목코드, TEXT), trade\_type (매수/매도, TEXT), quantity (체결수량, INTEGER), price (체결가격, REAL), fees (수수료, REAL, 선택), tax (세금, REAL, 선택).  
     * \_\_init\_\_에서 테이블이 없으면 생성하도록 합니다.  
  2. **거래 내역 저장 함수 구현**:  
     * add\_trade\_record(self, order\_no, timestamp, stock\_code, trade\_type, quantity, price, fees=0, tax=0)와 같은 메소드를 Database 클래스에 추가합니다.  
  3. **strategy.py 연동**:  
     * TradingStrategy 클래스의 on\_chejan\_data\_received 메소드 내에서 매수 또는 매도 체결이 완료되었을 때 (예: ev.주문상태 \== "체결"), 위 add\_trade\_record 함수를 호출하여 체결 내역을 DB에 기록하도록 수정합니다. 체결 시간은 ev.체결시간 등을 활용합니다.  
  4. **(선택 사항) 매매 결정 근거 기록 테이블 및 함수**:  
     * decisions 테이블 (예시): id, timestamp, stock\_code, decision\_type (매수/매도), reason (판단근거 요약 TEXT), related\_data (JSON TEXT, 당시 주요 데이터).  
     * add\_decision\_record(...) 함수 구현 및 strategy.py의 매수/매도 실행 직전에 호출.  
  5. **(선택 사항) 일별 계좌 스냅샷 테이블 및 함수**:  
     * daily\_snapshots 테이블 (예시): id, date (날짜 TEXT, PK), deposit (예수금, REAL), total\_asset\_value (총평가액, REAL).  
     * add\_daily\_snapshot(...) 함수 구현 및 main.py에서 장 마감 시간에 맞춰 호출 (또는 주기적 호출).  
       모든 DB 작업에는 적절한 예외 처리(try-except)를 추가해주세요.

### **마일스톤 4: ATS(대체거래소) 대응 및 추가 개선**

* **목표**: 대체거래소(NXT, ALL) 환경에서의 기본적인 시세 조회 및 주문 기능을 지원하고, 기타 프로그램 개선 사항을 적용합니다.  
* **예상 기간**: (사용자 설정 필요)

**태스크 4.1: ATS 종목코드 처리 및 기본 조회/주문 지원**

* **설명**: kiwoom\_api.py에서 KRX, NXT, ALL 시장 종목코드 규칙(\_NX, \_AL 접미사)에 따라 TR 요청 시 종목코드를 올바르게 설정하도록 수정합니다. 주문 시 시장 구분을 설정할 수 있도록 합니다 (필요한 경우).  
* **완료 기준**:  
  * settings.json의 관심종목에 \_NX, \_AL 접미사가 붙은 종목도 처리 가능.  
  * OPT10001, OPT10081 등 TR 요청 시 종목코드에 따라 접미사 자동 처리 또는 사용자가 명시한 코드 그대로 사용.  
  * 주문 함수(send\_order)에서 시장 구분을 파라미터로 받거나, 종목코드의 접미사를 통해 자동으로 시장을 구분하여 주문 API 호출 (키움 API 명세 확인 필요).  
* **실행 프롬프트 (ChatGPT 지시용)**:  
  키움 OpenAPI+ 자동매매 프로그램이 대체거래소(ATS) 환경에 기본적으로 대응할 수 있도록 \`kiwoom\_api.py\`를 수정해주세요.  
  참고 문서: \`\[붙임\]대체거래소(ATS) 도입에 따른 키움 Open API \+ 변경 안내\_ver20250303\_ver1.3.pdf\`

  1\.  \*\*TR 조회 시 종목코드 처리\*\*:  
      \* \`SetInputValue("종목코드", ...)\`를 사용하는 모든 TR 요청 함수(예: \`request\_stock\_basic\_info\`, \`request\_daily\_chart\_data\`)에서, 입력받는 종목코드 문자열이 \`\_NX\` 또는 \`\_AL\`로 끝나는 경우 해당 코드를 그대로 사용하고, 그렇지 않은 경우 일반 KRX 종목으로 간주하도록 합니다.  
      \* \`settings.json\`의 \`buy\_sell\_target\_stocks\`에 \`005930\_NX\`와 같이 ATS 시장 정보가 포함된 종목코드가 있어도 정상적으로 처리되어야 합니다.  
  2\.  \*\*주문 시 시장 구분 처리\*\*:  
      \* \`send\_order\` 메소드에서 주문을 전송할 때, 키움 API가 요구하는 시장 구분 값을 올바르게 설정해야 합니다.  
      \* \`sMarketGb\` (시장구분) 파라미터가 필요한 주문 TR(예: \`SendOrderCredit\` 또는 일반 \`SendOrder\`의 특정 인자)을 사용하는 경우, 종목코드의 접미사(\`\_NX\` 등)를 분석하여 적절한 시장구분 코드를 설정하도록 로직을 추가해주세요. (예: \`\_NX\`면 NXT 시장 코드, 일반 종목이면 KRX 시장 코드). 또는, \`send\_order\` 함수에 \`market\_code\`와 같은 인자를 추가하여 호출하는 쪽에서 명시적으로 시장을 지정할 수 있도록 합니다.  
      \* ATS 관련 주문 시 필요한 추가 파라미터가 있는지 API 문서를 다시 한번 확인하고 반영해주세요.  
  3\.  관련 변경 사항에 대해 주석을 추가하고, 어떤 시장의 종목을 조회/주문하는지 로그에 명시해주세요.

  **사용자님께 질문**: ATS 주문 시, 프로그램이 종목코드의 접미사를 보고 자동으로 시장을 판단하여 주문하도록 할까요, 아니면 주문을 요청하는 strategy.py 쪽에서 명시적으로 시장 구분 코드를 send\_order 함수에 전달하도록 할까요? (위 프롬프트는 두 가지 방안을 모두 언급했습니다.)

**태스크 4.2: (선택) 추가 개선 아이디어 적용**

* **설명**: 이전 논의에서 나왔던 추가 개선 아이디어 중 우선순위가 높은 것을 선택하여 적용합니다. (예: 오류 처리 세분화, 네트워크 재시도 로직, 안전 종료 기능 강화, 단위 테스트 확장 등)  
* **완료 기준**: (선택된 아이디어에 따라 다름)  
* **실행 프롬프트 (ChatGPT 지시용)**: (선택된 아이디어에 따라 구체화 필요)  
  // 예시: 안전 종료 기능 강화  
  \`main.py\`의 \`signal\_handler\` (Ctrl+C 처리) 함수를 개선하여, 프로그램 종료 시 현재 진행 중인 미체결 주문이 있다면 해당 주문을 취소하는 API 요청을 보내고, 모든 리소스(DB 연결 등)가 정상적으로 해제된 후 종료되도록 수정해주세요.

### **마일스톤 5: 통합 테스트 및 최종 검토**

* **목표**: 개선된 모든 기능을 통합하여 실제와 유사한 환경(모의투자)에서 테스트하고, 발견된 버그 수정 및 최종 안정성을 확보합니다.  
* **예상 기간**: (사용자 설정 필요)

**태스크 5.1: 통합 테스트 시나리오 작성 및 수행**

* **설명**: 다양한 매매 시나리오(정상 매수/매도, 손절, 익절, 트레일링 스탑, 연속 조회, API 오류 상황 등)를 포함하는 테스트 계획을 수립하고, "Dry Run" 모드 및 실제 모의투자 환경에서 테스트를 수행합니다.  
* **완료 기준**:  
  * 테스트 시나리오 문서화.  
  * 각 시나리오별 예상 결과 및 실제 결과 비교 기록.  
  * 테스트 중 발견된 모든 버그는 이슈 트래커(또는 pm.md에 기록)에 등록.  
* **실행 프롬프트 (ChatGPT 지시용)**: (테스트 계획 수립 지원 요청)  
  키움 OpenAPI+ 자동매매 프로그램의 통합 테스트를 위한 시나리오 목록을 작성해주세요. 프로그램의 주요 기능(사용자 정의 매수 전략, 손절, 익절, 트레일링 스탑, Dry Run 모드, ATS 종목 처리, API 통신 안정성, 로깅, DB 기록 등)을 포괄적으로 검증할 수 있어야 합니다. 각 시나리오에는 테스트 목적, 사전 조건, 실행 단계, 예상 결과, 실제 결과, 성공/실패 여부를 기록할 수 있는 항목을 포함해주세요.

  예시 시나리오:  
  1\.  \*\*시나리오명\*\*: 정상 매수 및 익절(1차) 후 트레일링 스탑 매도 (Dry Run 모드)  
      \* \*\*목적\*\*: 정의된 매수 전략에 따라 정상적으로 매수하고, 목표 수익률 도달 시 부분 익절하며, 이후 트레일링 스탑 조건에 따라 잔량이 매도되는지 확인.  
      \* \*\*사전 조건\*\*: \`settings.json\`에 \`dry\_run\_mode: true\` 설정, 특정 관심종목 A가 매수 전략 조건에 근접.  
      \* \*\*실행 단계\*\*: 프로그램 실행, 종목 A의 가격을 수동으로 조작하여 매수 조건 \-\> 익절 조건 \-\> 트레일링 스탑 조건 순으로 만족시킴.  
      \* \*\*예상 결과\*\*: 로그에 매수/익절/트레일링스탑 주문(Dry Run) 기록, \`stock\_data\` 상태 변화 정상, DB에 거래 내역(가상) 기록.  
      \* ...

**태스크 5.2: 버그 수정 및 최종 안정화**

* **설명**: 통합 테스트에서 발견된 모든 버그를 수정하고, 장시간 운영 테스트(모의투자)를 통해 프로그램의 최종 안정성을 검증합니다.  
* **완료 기준**:  
  * 등록된 모든 주요 버그 수정 완료.  
  * 최소 N시간 (예: 8시간) 이상 모의투자 환경에서 오류 없이 안정적으로 구동 확인.  
  * 최종 코드 검토 및 pm.md 문서 업데이트.  
* **실행 프롬프트 (ChatGPT 지시용)**: (발견된 버그에 따라 구체적으로 지시)  
  // 예시: 특정 버그 수정 요청  
  통합 테스트 중 "\[버그 ID 또는 설명\]" 버그가 발견되었습니다. 원인을 분석하고 \`\[관련 파일명\]\`의 \`\[관련 함수/클래스명\]\` 부분을 수정하여 버그를 해결해주세요. 수정 후에는 해당 버그가 재현되지 않음을 확인하고, 관련 단위 테스트가 있다면 업데이트해주세요.

## **3\. 참고 자료**

* pm.md (본 프로그램 개발 현황 및 계획 문서)  
* outline.md (프로그램 초기 아웃라인)  
* kiwoom\_openapi\_plus\_devguide\_ver\_1.1.pdf (키움 OpenAPI+ 개발 가이드)  
* \[붙임\]대체거래소(ATS) 도입에 따른 키움 Open API \+ 변경 안내\_ver20250303\_ver1.3.pdf  
* Kiwoom\_Securities\_Alternative\_Exchange\_Guide\_Booklet\_Single-Sided.pdf  
* 프로젝트 내 \*.py 소스 코드 및 settings.json